# Bitget API
BITGET_API_KEY=
BITGET_SECRET=
BITGET_PASSPHRASE=

# Telegram (Sprint 4)
TELEGRAM_BOT_TOKEN=
TELEGRAM_CHAT_ID=
HEARTBEAT_INTERVAL=3600

# Database
DATABASE_URL=sqlite:///data/scalp_radar.db

# Logging
LOG_LEVEL=DEBUG

# Data Engine
ENABLE_WEBSOCKET=true

# Live Trading (Sprint 5a)
#
# LIVE_TRADING : active l'Executor qui passe des ordres réels sur Bitget.
#   false (défaut) = simulation only, le Simulator tourne en paper trading,
#                    aucun ordre n'est envoyé à Bitget.
#   true           = l'Executor démarre, écoute les signaux du Simulator,
#                    et réplique les trades en ordres réels sur Bitget.
#
# Combinaisons typiques :
#   LIVE_TRADING=false → paper trading only (pas d'Executor)
#   LIVE_TRADING=true  → PRODUCTION, ordres réels mainnet
# Note : Sandbox Bitget supprimé (cassé, ccxt #25523) — mainnet only
LIVE_TRADING=false

# Adaptive Selector Overrides (Hotfix 28a + 30)
#
# Ces variables overrident risk.yaml pour faciliter le déploiement prod
# sans éditer les fichiers YAML versionnés.
#
# SELECTOR_BYPASS_AT_BOOT : autorise toutes les stratégies au boot (cold start)
#   true  = bypass min_trades/return/PF (live_eligible requis)
#   false = selector applique tous les checks normalement
#   Non défini = utilise la valeur de risk.yaml (false par défaut)
SELECTOR_BYPASS_AT_BOOT=false
#
# FORCE_STRATEGIES : liste de stratégies qui bypassent net_return/PF checks
#   Format: comma-separated (ex: "grid_atr,grid_trend")
#   Les stratégies forcées doivent toujours être live_eligible + is_active
#   Non défini = utilise la valeur de risk.yaml ([] par défaut)
# Exemple prod : FORCE_STRATEGIES=grid_atr
#FORCE_STRATEGIES=

# ACTIVE_STRATEGIES : filtre les stratégies actives au runtime (vide = toutes les enabled)
#   Format: comma-separated (ex: "grid_atr,grid_boltrend")
#   Seules les stratégies listées seront créées par la Factory
# Exemple prod : ACTIVE_STRATEGIES=grid_atr,grid_boltrend
#ACTIVE_STRATEGIES=

# === Multi-Executor (Sprint 36b) ===
# Clés API par sous-compte Bitget (optionnel — fallback sur clés globales)
# Convention : BITGET_API_KEY_{STRATEGY_UPPER}
# Si les 3 clés d'une stratégie sont définies, un sous-compte dédié est utilisé.
# Sinon, les clés globales sont partagées (warning rate limit si >1 executor).
#BITGET_API_KEY_GRID_ATR=
#BITGET_SECRET_GRID_ATR=
#BITGET_PASSPHRASE_GRID_ATR=
#BITGET_API_KEY_GRID_MULTI_TF=
#BITGET_SECRET_GRID_MULTI_TF=
#BITGET_PASSPHRASE_GRID_MULTI_TF=
